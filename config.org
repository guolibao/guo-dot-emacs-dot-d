#+STARTUP: overview
#+TITLE: guo's Emacs
#+CREATOR: Dawid 'daedreth' Eckert
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
* Programming
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** company mode
*** company mode normal install and setting
I setthe delay for company modeto kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
                          (define-key company-active-map (kbd "M-n") nil)
                          (define-key company-active-map (kbd "M-p") nil)
                          (define-key company-active-map (kbd "C-n") #'company-select-next)
                          (define-key company-active-map (kbd "C-p") #'company-select-previous)
                          (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

*** company-mode debug for company-gtags not working
#+BEGIN_SRC emacs-lisp
  (defun company-diag ()
    (interactive)
    (let* ((bb company-backends)
           backend
           (prefix (cl-loop for b in bb
                       thereis (let ((company-backend b))
                                 (setq backend b)
                                 (company-call-backend 'prefix))))
           cc)
      (when (stringp prefix)
        (setq cc (let ((company-backend backend))
                   (company-call-backend 'candidates prefix))))
      (pop-to-buffer (get-buffer-create "*company-diag*"))
      (setq buffer-read-only nil)
      (erase-buffer)
      (insert "company-backends: " (pp-to-string bb))
      (insert "\n")
      (insert "Used backend: " (pp-to-string backend))
      (insert "\n")
      (insert "Prefix: " (pp-to-string prefix))
      (insert "\n")
      (insert (message  "Candidates number: %i" (length cc)))
      (special-mode)))

#+END_SRC

** ggtags
#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :ensure t)
  ;; get rid of M-ss keymap for ggtags-navigation-isearch-forward,
  ;; because it is conflict with M-s for avy-find-char

  ;; (define-key ggtags-navigation-map (kbd "\M-ss") nil)

  ;; remove the key to ggtags-navigation-last-error, because it conflicts with goto the beginning of the page
  ;; (define-key ggtags-navigation-map (kbd "\M->") nil)

  ;; remove the key to firt-error, because it conflicts with goto the end of the page
  ;; (define-key ggtags-navigation-map (kbd "\M-<") nil)
  (define-key ggtags-mode-prefix-map "\M-g" nil) ;remove ggtags-grep default binding, for conflicts with magit
  (define-key ggtags-mode-prefix-map "\M-r" 'ggtags-grep)

#+END_SRC
** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decide to drop it
in favor of =company=, and it turns out to have been a great decision

*** c/c++
**** yasnippet

#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck-clang-analyzer
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
      (flycheck-clang-analyzer-setup)))
#+END_SRC

**** company
Require clang and libclang-dev to be installed,
#+BEGIN_SRC shell
sudo apt-get install clang
sudo apt-get install libclang-dev
mkdir build in ~/.emacs.d/elpa/irony/server
cd build
cmake -DLIBCLANG_LIBRARY=/usr/lib/llvm-3.8/lib/libclang.so.1
-DLIBCLANG_INCLUDE_DIR=/usr/lib/llvm-3.8/include 
~/.emacs.d/ 
/home/guo/.emacs.d/elpa/irony/server
#+END_SRC
for building irony server in the shell terminal, 
and then =M-x irony-install-server= in emacs

#+BEGIN_SRC emacs-lisp
  ;; 1. install irony, irony-eldoc, flycheck-irony, company-irony

  (use-package company-c-headers
    :ensure t)

  ;;   (defun c-mode-company-init ()
  ;;     (setq company-backends '((company-c-headers
  ;;                               company-dabbrev-code
  ;;                               company-gtags
  ;;                               company-irony
  ;;                               ))))

  (use-package company-irony
    :ensure t)

  ;; (with-eval-after-load 'company
  ;;   (add-hook 'c++-mode-hook 'c-mode-company-init)
  ;;   (add-hook 'c-mode-hook 'c-mode-company-init))
  ;; ;; only install irony if it is linux system
  ;; ;; for windows 'windows-nt' for Mac OS 'darwin'

  ;; (if (eq system-type 'gnu/linux)
      (use-package irony
        :ensure t
        :config
        (if (eq system-type 'windows-nt)
            (setq w32-pipe-read-delay 0)))
  ;; )

  ;;       :config
  ;;       (add-hook 'c++-mode-hook 'irony-mode)
  ;;       (add-hook 'c-mode-hook 'irony-mode)
  ;;       (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)))

  (use-package irony-eldoc
    :ensure t)

  (use-package flycheck-irony
    :ensure t)

  ;; 2. install irony-server

  ;; Open any .cpp file and make sure that irony-mode is on
  ;; M-x irony-install-server
  ;; Important: to force irony-server to use llvm-3.4, you need to add cmake options
  ;; -DLIBCLANG_INCLUDE_DIR=/usr/lib/llvm-3.4/include and
  ;; -DLIBCLANG_LIBRARIES=/usr/lib/llvm-3.4/lib/libclang-3.4.so



  ;; 3. Setup irony-mode

  ;; =============
  ;; irony-mode
  ;; =============
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  ;; ============= ;; company mode ;; =============
  (add-hook 'c++-mode-hook 'company-mode)
  (add-hook 'c-mode-hook 'company-mode)
  ;; replace the `completion-at-point' and `complete-symbol' bindings in
  ;; irony-mode's buffers by irony-mode's function
  (defun my-irony-mode-hook ()
    (define-key irony-mode-map [remap completion-at-point] 'irony-completion-at-point-async)
    (define-key irony-mode-map [remap complete-symbol] 'irony-completion-at-point-async))
  (add-hook 'irony-mode-hook 'my-irony-mode-hook)
  (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
  (eval-after-load 'company '(add-to-list 'company-backends '(company-irony company-c-headers)))
  ;; (optional) adds CC special commands to `company-begin-commands' in order to
  ;; trigger completion at interesting places, such as after scope operator
  ;; std::|
  (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
  ;; =============
  ;; flycheck-mode
  ;; =============
  (add-hook 'c++-mode-hook 'flycheck-mode)
  (add-hook 'c-mode-hook 'flycheck-mode)
  (eval-after-load 'flycheck '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup))
  ;; =============
  ;; eldoc-mode
  ;; =============
  (add-hook 'irony-mode-hook 'irony-eldoc)
  ;; ==========================================
  ;; (optional) bind TAB for indent-or-complete
  ;; ==========================================
  (defun irony--check-expansion ()
    (save-excursion
      (if (looking-at "\\_>") t (backward-char 1)
          (if (looking-at "\\.") t (backward-char 1)
              (if (looking-at "->") t nil)))))

  (defun irony--indent-or-complete ()
    "Indent or Complete"
    (interactive)
    (cond ((and (not (use-region-p))
                (irony--check-expansion))
           (message "complete")
           (company-complete-common))
          (t (message "indent")
             (call-interactively 'c-indent-line-or-region))))

  (defun irony-mode-keys ()
    "Modify keymaps used by `irony-mode'."
    (local-set-key (kbd "TAB")
                   'irony--indent-or-complete)
    (local-set-key [tab] 'irony--indent-or-complete))

  (add-hook 'c-mode-common-hook 'irony-mode-keys)
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))


#+END_SRC

company-c-headers provides auto-completion for c/c++ headers using company,
If you want to complete C++ header files, you have to add its paths,
since by default =company-c-headers= only includes these two system
include paths: =/usr/include/= and =/usr/local/include/=.

To enable C++ header completion for standard libraries, you have to add
its path, for example, like this:
=(add-to-list 'company-c-headers-path-system "/usr/include/c++/4.8/")=
After that, you can complete C++ header files.

To complete project local, use =company-c-headers-path-user= and
put it in =.dir-locals.el=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'company-c-headers-path-system "C:/Qt/Qt5.8.0\\5.8\\Src/qtsensors/include/QtSensors")
  ;; add the below to .dir-locals.el file
  ;; ((nil . ((company-c-headers-path-user . ("D:/Work/Learning/Emacs/my_program/my_inc/")))))
#+END_SRC
**** ggtags
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'ggtags
    (add-hook 'c++-mode-hook 'ggtags-mode)
    (add-hook 'c-mode-hook 'ggtags-mode))
#+END_SRC
*** python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC

**** company
=pip install sexpdata=
=pip install epc=
=pip install virtualenv=
for company-jedi, sometimes it fails to install server,
may try to use the command from commmand line
#+BEGIN_SRC shell
~/.emacs.d/.python-environments/default/bin/pip install --upgrade ~/.emacs.d/elpa/jedi-core-20170121.610/
#+END_SRC
or using below, if above command fail, using =sudo=
#+BEGIN_SRC shell
sudo ~/.emacs.d/.python-environments/default/bin/pip install --upgrade ~/.emacs.d/elpa/jedi-core-20170121.610/
#+END_SRC
to install the server
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
    (require 'company)
    ;; (setq jedi:environment-virtualenv (list (expand-file-name "~/.emacs.d/.python-environments/")))
    ;; (add-hook 'python-mode-hook 'jedi:setup)
    ;; (setq jedi:complete-on-dot t)
    ;; (setq jedi:use-shortcuts t)
    (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code
                                    ))))

  (add-hook 'python-mode-hook 'python-mode-company-init)
#+END_SRC

*** emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbc1")
    (setq slime-contribes '(slime-fancy)))
#+END_SRC

*** bash
to determine the mode use:
=M-: major-mode=
for shell script, it is sh-mode
for =M-x shell=, it is shell-mode
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'company-mode)

  (defun sh-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
    (require 'company)
    (add-hook 'sh-mode-hook 'sh-mode-company-init))
#+END_SRC
* Minor convenience
** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Visitthe config.org file"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun config-init ()
    "Visitthe init.el file"
    (interactive)
    (find-file "~/.emacs.d/init.el"))
  (global-set-key (kbd "C-c i") 'config-init)
#+END_SRC

** Reloading the configuration
Simply pressing =C-c r= will reload the file, very handy.
You can also manually invoke =M-x config-reload=
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
      "Reload ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

** Subwords
Emacs treats camelCase Strings as a single word by default, this changes said
behavior
#+BEGIN_SRC emacs-lisp
  ;; (global-subword-mode 1)
#+END_SRC

** Electric
If you write andy code, you may enjoy this. Typing the first character
in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already.
Quoting something? It's clocsed for you already.

You can easily add and remove pairs yourself, have a look

#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '(
			     (?\{ . ?\})
			     (?\( . ?\))
			     (?\[ . ?\])
			     (?\" . ?\")
			     ))
#+END_SRC
 
An now to enable it
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
#+END_SRC
** Rainbow
When ever enable a color code, will colorize the background to that color, for example #00FF00
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init (rainbow-mode 1))
#+END_SRC
** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace
character is encountered. You may not like it, 
thus disable it if you must, but it's pretty decent.

=BackSpace= will delete all the white space in between.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful
for any language using them, especially lisp
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** sudo edit
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
    ("s-e" . sudo-edit))

#+END_SRC
** shwo parenthesis mode
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
* Moving around Emacs
** IDO
*** enable ido mode
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching nil)
  (setq ido-create-new-buffer 'always)
  (setq ido-everywhere 1)
  (ido-mode 1)
#+END_SRC

*** ido-vertical-mode
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

*** Smex
for "M-x" quickly command completion and selection
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init
    (smex-initialize)
    :bind
    ("M-x" . smex))
#+END_SRC

** Helm
It is rather similar to ido-vertical though
#+BEGIN_SRC emacs-lisp
  ;; (use-package helm
  ;;   :ensure t
  ;;   :bind
  ;;   ("C-x C-f" . 'helm-find-files)
  ;;   ("C-x C-b" . 'helm-buffers-list)
  ;;   ("M-x" . 'helm-M-x)
  ;;   :config
  ;;   (defun guo/helm-hide-minibuffer ()
  ;;     (when (with-helm-buffer helm-echo-input-in-header-line)
  ;;       (let((ov (make-overlay (point-min) (point-max) nil nil t)))
  ;;         (overlay-put ov 'window (selected-window))
  ;;         (overlay-put ov 'face
  ;;                      (let ((bg-color (face-background 'default nil)))
  ;;                        `(:background ,bg-color :foreground ,bg-color)))
  ;;         (setq-local cursor-type nil))))
  ;;   (add-hook 'helm-minibuffer-set-up-hook 'guo/helm-hide-minibuffer)
  ;;   (setq helm-autoresize-max-height 0
  ;;         helm-autoresize-min-height 40
  ;;         helm-M-x-fuzzy-match t
  ;;         helm-buffers-fuzzy-matching t
  ;;         helm-recentf-fuzzy-match t
  ;;         helm-semantic-fuzzy-match t
  ;;         helm-imenu-fuzzy-match t
  ;;         helm-split-window-in-side-p nil
  ;;         helm-move-to-line-cycle-in-source nil
  ;;         helm-ff-search-library-in-sexp t
  ;;         helm-scroll-amount 8
  ;;         helm-echo-input-in-header-line t)

  ;;   :init
  ;;   (helm-mode 1))
  ;; (require 'helm-config)
  ;; (helm-autoresize-mode 1)
  ;; (define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
  ;; (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
#+END_SRC
**  buffers
*** enable ibuffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

*** expert
deleting buffers from ibuffer will not ask to confirm
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC

*** switch buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ido-switch-buffer)
#+END_SRC

** avy
for quick go to a place by searching a character and selet the overlay letters
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("M-s" . avy-goto-char)
    ("\C-c a" . avy-goto-char))
#+END_SRC

** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    ;; aw-keys - the initial characters used in window labels, default is 1-9
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    ;; if you want these keys to work with fewer than three windows, you need to have aw-dispatch-always to t
    (setq aw-dispatch-always t)
    :bind
    ([remap other-window] . ace-window))
#+END_SRC

** following window splits
After you split window, your focus remains in the previous one. 
This annoyed me so much, I wrote these two, they take care of it
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-hoizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Swiper 
swiper is a better search for default search
#+BEGIN_SRC emacs-lisp
  ;; (use-package swiper
  ;;   :ensure t
  ;;   :bind("C-s" . 'swiper))
#+END_SRC

** which-key
To tell you the keyboard binding when pressing =C-c= =C-x= =...=
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC

* Text manipulation
Here I shall collect self-made functions that make editing text easier.
** Improved kill-word
Why on earth does a function called kill-word not .. kill a word. It 
instead deletes characters from your cursors position to the end
of the word, lets make a quick fix and bind it properly
#+BEGIN_SRC emacs-lisp
  (defun guo/kill-inner-word ( )
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim. "
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'guo/kill-inner-word)
#+END_SRC

** copy a word
#+BEGIN_SRC emacs-lisp
  (defun guo/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'guo/copy-whole-word)
#+END_SRC

** copy a line 
#+BEGIN_SRC emacs-lisp
  (defun guo/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'guo/copy-whole-line)
#+END_SRC
** kill a line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC

* My Own Setting Section
** Align Regular Expression Setting
*** when align-regexp, using spaces instead of tabs
#+BEGIN_SRC emacs-lisp
(defadvice align-regexp (around align-regexp-with-spaces activate)
  (let ((indent-tabs-mode nil))
    ad-do-it))
#+END_SRC

** Disable Auto Save, Auto Backup and Create Lockfile
#+BEGIN_SRC emacs-lisp
;; disable auto-save and auto-backup
(setq auto-save-default nil)
(setq make-backup-files nil)
;; don't use lockfiles to avoid editng collisions
(setq create-lockfiles nil)

;; store all backup and autosave files in the tmp dir
;; (setq backup-directory-alist
;;       `((".*" . ,temporary-file-directory)))
;; (setq auto-save-file-name-transforms
;;       `((".*" ,temporary-file-directory t)))
#+END_SRC

** High Light Symbol Key Binding
#+BEGIN_SRC emacs-lisp
  ;; highlight-symbol key binding
  (use-package highlight-symbol
    :ensure t
    :config
    (global-set-key [(shift f8)] 'highlight-symbol)
    (global-set-key [f8] 'highlight-symbol-next)
    (global-set-key [(control f8)] 'highlight-symbol-prev)
    (global-set-key [(meta f8)] 'highlight-symbol-query-replace))
#+END_SRC

** Google Translate Direction
#+BEGIN_SRC emacs-lisp
  (use-package google-translate
    :ensure t
    :config
    (setq google-translate-translation-directions-alist
          '(("ja" . "en") ("en" . "de") ("de" . "fr") ("fr" . "de"))))
#+END_SRC

** #If 0 ... #endif Color Dim
#+BEGIN_SRC emacs-lisp
;; #if 0 ... #endif to change the code color as comment color
(add-to-list 'load-path' "~/.emacs.d/MyLisp/")
(require 'never-comment)
(never-comment-init)
#+END_SRC


** Auto Complete
#+BEGIN_SRC emacs-lisp
  ;; (use-package auto-complete
  ;;   :ensure t
  ;;   :config
  ;;   ;; start auto complete with emacs
  ;;   (require 'auto-complete)
  ;;   ;; do default config for auto-complete
  ;;   (require 'auto-complete-config)
  ;;   (ac-config-default))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'ac-modes 'latex-mode)	;Make auto-complete aware of `latex-mode`
#+END_SRC

# ** Yasnippet
# #+BEGIN_SRC emacs-lisp
#   (require 'yasnippet)
#   ;; (yas-global-mode 1)
# #+END_SRC


# ** Add the package-archives, not used at this moment
# #+BEGIN_SRC emacs-lisp
#   ;; (add-to-list 'package-archives '("ELPA"  . "http://tromey.com/elpa/"))
# #+END_SRC

** qml mode for QT qml file
#+BEGIN_SRC emacs-lisp
  ;; (autoload 'qml-mode "qml-mode" "Editing Qt Declarative." t)
  ;; (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode))
  (use-package qml-mode
    :ensure t)
#+END_SRC


** Org Mode Setting
*** For plantuml to work in org mode
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)
                                                             (plantuml . t)
                                                             (C . t)
                                                             (gnuplot . t)
                                                             (R . t)
                                                             (sh . t)
                                                             (ditaa . t)
                                                             (calc . t)
                                                             (latex . t)
                                                             )))
  (setq org-plantuml-jar-path
        (expand-file-name "~/plantuml.jar"))

#+END_SRC

**** plantuml-mode 
install plantuml-mode
#+BEGIN_SRC emacs-lisp
  (use-package plantuml-mode
    :ensure t)
#+END_SRC

**** plantuml example in org mode
#+BEGIN_SRC plantuml :file image/my-diagram.png
  title Authentication Sequence

  Alice->Bob: Authentication Request
  note right of Bob: Bob thinks about it
  Bob->Alice: Authentication Response
#+END_SRC

#+RESULTS:
[[file:image/my-diagram.png]]

**** ditaa.jar where should be place
execute the below function, to find where should the ditaa.jar should be placed
#+BEGIN_SRC emacs-lisp
  (defun find-location-to-place-ditaa ()
    "find the location where the ditaa.jar should be placed "
    (interactive)
    (message 
     (expand-file-name
      "ditaa.jar"
      (file-name-as-directory
       (expand-file-name
	"scripts"
	(file-name-as-directory
	 (expand-file-name
	  "../contrib"
	  (file-name-directory (org-find-library-dir "org")))))))))

#+END_SRC

**** ditaa in orgmode example
refer to http://ditaa.sourceforge.net/
=-A, --no-antialias=
=-d,--debug=
=-E,--no-separation=
=-e,--encoding=
=-r,--round-corners=
==--help==
==-S,--no-shadows=
press C-c C-c to execute the below ditaa
#+BEGIN_SRC ditaa :file image/hello-world.png :cmdline -E

       +-----------+
       |cBLU       |
       |           |
       |           |
       |      +----+
       |      |cPNK|
       |      |    |
       +------+----+
#+END_SRC

#+RESULTS:
[[file:image/hello-world.png]]

** Open the folder containing the current file by the default explorer of the OS
Using -brwse-url-of-file should work when given a directory
#+BEGIN_SRC emacs-lisp
  (defun guo/browse-file-directory ()
    "Open the crrent file's directory however the OS would"
    (interactive)
    (if default-directory
	(browse-url-of-file (expand-file-name default-directory))
      (error "No `default-directory` to open")))
#+END_SRC

* org Mode
** Common settings
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

** htmlize
Systax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Easy to add emacs-lisp template in org mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
* screen shot
** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
  (defun guo/take-screenshot ()
    "Takes a fullscreen screen shot of the current workspace"
    (interactive)
    (when window-system
      (cl-loop for i downfrom 3 to 1 do
	    (progn
	      (message (concat (number-to-string i) "..."))
	      (sit-for 1)))
      (message "Cheese!")
      (start-process "screenshot" nil "import" "-window" "root"
		     (concat (getenv "HOME") "/Desktop/" (cl-subseq (number-to-string (float-time)) 0 10) ".png"))
      (message "Screenshot taken")))
  (global-set-key (kbd "<print>") 'guo/take-screenshot)

#+END_SRC

** Screenshotting region
#+BEGIN_SRC emacs-lisp
  (defun guo/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
		  (concat (getenv "HOME") "/Desktop/" (cl-subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
  (global-set-key (kbd "<Scroll_Lock>") 'guo/take-screenshot-region)
#+END_SRC
* git integration
** magit
magit-file-mode-map define some short-cut key for magit as follows:
| Short-Cut key | magit command        |
|---------------+----------------------|
| =C-xg=        | magit-status         |
| =C-x\M-g=     | magit-dispatch-popup |
| =C-c\M-g=     | magit-file-popup     |
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq magit-commit-summary-max-length 50))

  ;; (define-key magit-file-mode-map (kbd "\C-x\C-g") 'magit-file-popup)
#+END_SRC
* set LD_LIBRARY_PATH
** function for set LD_LIBRARY_PATH
#+BEGIN_SRC emacs-lisp
  (defun guo/set-ld-library-Path (path)
    (interactive)
    (setenv "LD_LIBRARY_PATH"
            (let((current (getenv "LD_LIBRARY_PATH"))
                 (new path))
              (if current
                  (concat new ":" current)
                new))))
#+END_SRC

** set LD_LIBRARY_PATH
use =gcc -xc++ -E -v= to search for the gcc search path,
used for irony-mode for searching library or path.
#+BEGIN_SRC shell
/usr/include/c++/4.8
/usr/include/x86_64-linux-gnu/c++/4.8
/usr/include/c++/4.8/backward
/usr/lib/gcc/x86_64-linux-gnu/4.8/include
/usr/local/include
/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed
/usr/include/x86_64-linux-gnu
/usr/include
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (guo/set-ld-library-Path "/usr/lib/llvm-3.4/lib/")
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (getenv "LD_LIBRARY_PATH")
#+END_SRC

* set LIBCLANG_LIBRARY
#+BEGIN_SRC emacs-lisp
  (setenv "LIBCLANG_LIBRARY" "/usr/lib/llvm-3.4/lib/libclang.so.1")
  (getenv "LIBCLANG_LIBRARY")
#+END_SRC

* set LIBCLANG_INCLUDE_DIR
#+BEGIN_SRC emacs-lisp
  (setenv "LIBCLANG_INCLUDE_DIR" "/usr/lib/llvm-3.4/include")
  (getenv "LIBCLANG_INCLUDE_DIR")
#+END_SRC

* cygwin-shell function and enable if if it is windows
#+BEGIN_SRC emacs-lisp
  ;; for windows 'windows-nt' for Mac OS 'darwin'
  ;; shell-file-name is thevariable that controls wich shell Emacs uses
  ;; when it wants to runa shell command.

  ;; explicit-shell-file-name is thevariable that controls wich shell =M-x shell=
  ;; starts up.
  (if (eq system-type 'windows-nt)
      (defun guo/cygwin-shell ()
	"Run cygwin bash in shell mode."
	(interactive)
	(let ((explicit-shell-file-name "C:/cygwin64/bin/bash")
	      )
	  (call-interactively 'shell)))
    )
#+END_SRC
* project find file
#+BEGIN_SRC emacs-lisp
;; Find file in project
(global-set-key (kbd "C-x M-f") 'project-find-file)
#+END_SRC
* Auctex
** 1) auctex install from package install, 
try this first, if not working, need to install manually as below 2
#+BEGIN_SRC emacs-lisp
  ;; (use-package auctex			;
  ;;   :defer t
  ;;   :ensure t
  ;;   :config
  ;;   (setq TeX-auto-save t))

  ;; alternative or better configuration
  ;; (use-package tex
  ;;   :defer t
  ;;   :ensure auctex
  ;;   :config
  ;;   (setq TeX-auto-save t))
#+END_SRC

** 2) manual install auctex
auctex is not working solution for windows 7 in company
auctex-12.1 installed from package-install is not working on windows 7 in company
need to install auctex manually.

If installed from package-install, delete the package from elpa directory,
remove the auctex from init.el file from packaged-installed

uncomment the code below
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path' "~/.emacs.d/site-lisp/auctex-11.89")
  ;; (require 'tex-site)
#+END_SRC
* Set PATH and exec-path
#+BEGIN_SRC emacs-lisp
  (if (eq system-type 'windows-nt)
      (setenv "PATH"
	      (concat
	       "C:\\msys64\\usr\\bin" ";"
	       "C:\\msys64\\mingw64\\bin" ";"
	       "C:\\Qt\\Qt5.8.0\\5.8\\mingw53_32\\bin" ";"
	       (getenv "PATH")
	       )
	      )

    (setq exec-path (append '("C:/msys64/usr/bin"
			      "C:/msys64/mingw64/bin"
			      "C:/Qt/Qt5.8.0/5.8/mingw53_32/bin")
			    exec-path)))


#+END_SRC

* Show current file's full path
#+BEGIN_SRC emacs-lisp
  ;; (setq frame-title-format
  ;;       (list (format "%s %%S: %%j " (system-name))
  ;;             '(buffer-file-name "%f" (dired-directory dired-directory "%b"))))

  (defun show-file-name ()
    "Showing thefull pathfile name in the ninibuffer."
    (interactive)
    (message (buffer-file-name)))

  (global-set-key [C-f1] 'show-file-name)
#+END_SRC

* qt-pro-mode
GNU Emacs major-mode for Qt build-system files
#+BEGIN_SRC emacs-lisp
  (use-package qt-pro-mode
    :ensure t
    :mode ("\\.pro\\'" "\\.pri\\'"))
#+END_SRC
* dts-mode
For editing device trees .dts and dti files for linux kernel
#+BEGIN_SRC emacs-lisp
  (use-package dts-mode
    :ensure t)
#+END_SRC
* macro
** elmacro
Shows Keyboard macros or latest interactive commands as emacs lisp
#+BEGIN_SRC emacs-lisp
  (use-package elmacro
    :ensure t
    :init (elmacro-mode))
#+END_SRC
*** generated emacs lisp from keyboard macro with elmacro
**** replace "" to <>
For example to replace user c header to system c header include, =#include "header"= to =#include <header>=
#+BEGIN_SRC emacs-lisp
    (defun guo/replace-double-quotes-with-angle-brackets ()
      (interactive)
      (move-beginning-of-line 1)
      (set-mark-command nil)
      (move-end-of-line 1)
      (replace-regexp "\"\\(.+\\)\"" "<\\1>" nil
                      (if
                          (use-region-p)
                          (region-beginning))
                      (if
                          (use-region-p)
                          (region-end))
                      nil))
  (global-set-key (kbd "\C-x\C-kA") 'guo/replace-double-quotes-with-angle-brackets)
#+END_SRC
* showing line-number
#+BEGIN_SRC emacs-lisp
  ;; show the line number on the left
  (global-linum-mode 1)
  ;; show thecurrent line and column for your cursor
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC
* set custom theme
#+BEGIN_SRC emacs-lisp
  (load-theme 'misterioso)
#+END_SRC
* set truncate line to true
set the truncate line to true so that a long line will not wrap around
use =M-x toggle-truncate-line= to wrap line or disable 
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC
* CEDET and EDE
** ECB emacs code brouwser
#+BEGIN_SRC emacs-lisp
  ;; (global-ede-mode 1)
  ;; (require 'semantic/sb)
  ;; (semantic-mode 1)
  (use-package ecb
    :ensure t)
#+END_SRC
* Code folding
** hs minor mode enable
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook 'hs-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'hs-minor-mode)
  (add-hook 'java-mode-hook 'hs-minor-mode)
  (add-hook 'lisp-mode-hook 'hs-minor-mode)
  (add-hook 'sh-mode-hook 'hs-minor-mode)
#+END_SRC
* beamer for latex

Need to org-beamer-mode

  #+BEGIN_SRC emacs-lisp
  ;; allow for export=>beamer by placing

;; #+LaTeX_CLASS: beamer in org files
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
  ;; beamer class, for presentations
  '("beamer"
     "\\documentclass[11pt]{beamer}\n
      \\mode<{{{beamermode}}}>\n
      \\usetheme{{{{beamertheme}}}}\n
      \\usecolortheme{{{{beamercolortheme}}}}\n
      \\beamertemplateballitem\n
      \\setbeameroption{show notes}
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{hyperref}\n
      \\usepackage{color}
      \\usepackage{listings}
      \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\\color{blue}\\bfseries,
  commentstyle=\\color{red},
  }\n
      \\usepackage{verbatim}\n
      \\institute{{{{beamerinstitute}}}}\n          
       \\subject{{{{beamersubject}}}}\n"

     ("\\section{%s}" . "\\section*{%s}")
     
     ("\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}"
       "\\begin{frame}[fragile]\\frametitle{%s}"
       "\\end{frame}")))

  ;; letter class, for formal letters

  (add-to-list 'org-export-latex-classes

  '("letter"
     "\\documentclass[11pt]{letter}\n
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{color}"
     
     ("\\section{%s}" . "\\section*{%s}")
     ("\\subsection{%s}" . "\\subsection*{%s}")
     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
     ("\\paragraph{%s}" . "\\paragraph*{%s}")
     ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  #+END_SRC
