#+STARTUP: overview
#+TITLE: guo's Emacs
#+CREATOR: Dawid 'daedreth' Eckert
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;
* Programming
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC

** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** company mode
*** company mode normal install and setting
I setthe delay for company modeto kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 3))

  (with-eval-after-load 'company
                          (define-key company-active-map (kbd "M-n") nil)
                          (define-key company-active-map (kbd "M-p") nil)
                          (define-key company-active-map (kbd "C-n") #'company-select-next)
                          (define-key company-active-map (kbd "C-p") #'company-select-previous)
                          (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

*** company-mode debug for company-gtags not working
#+BEGIN_SRC emacs-lisp
  (defun company-diag ()
    (interactive)
    (let* ((bb company-backends)
           backend
           (prefix (cl-loop for b in bb
                       thereis (let ((company-backend b))
                                 (setq backend b)
                                 (company-call-backend 'prefix))))
           cc)
      (when (stringp prefix)
        (setq cc (let ((company-backend backend))
                   (company-call-backend 'candidates prefix))))
      (pop-to-buffer (get-buffer-create "*company-diag*"))
      (setq buffer-read-only nil)
      (erase-buffer)
      (insert "company-backends: " (pp-to-string bb))
      (insert "\n")
      (insert "Used backend: " (pp-to-string backend))
      (insert "\n")
      (insert "Prefix: " (pp-to-string prefix))
      (insert "\n")
      (insert (message  "Candidates number: %i" (length cc)))
      (special-mode)))

#+END_SRC

** ggtags
#+BEGIN_SRC emacs-lisp
  (use-package ggtags
    :ensure t)
#+END_SRC
** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decide to drop it
in favor of =company=, and it turns out to have been a great decision

*** c/c++
**** yasnippet

#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck-clang-analyzer
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
      (flycheck-clang-analyzer-setup)))
#+END_SRC

**** company
Require clang and libclang-dev to be installed,
#+BEGIN_SRC shell
sudo apt-get install clang
sudo apt-get install libclang-dev
mkdir build in ~/.emacs.d/elpa/irony/server
cd build
cmake -DLIBCLANG_LIBRARY=/usr/lib/llvm-3.8/lib/libclang.so.1
-DLIBCLANG_INCLUDE_DIR=/usr/lib/llvm-3.8/include 
~/.emacs.d/ 
/home/guo/.emacs.d/elpa/irony/server
#+END_SRC
for building irony server in the shell terminal, 
and then =M-x irony-install-server= in emacs

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (defun c-mode-company-init ()
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-gtags
                              company-irony
                              ))))

  (use-package company-irony
    :ensure t)

  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'c-mode-company-init)
    (add-hook 'c-mode-hook 'c-mode-company-init))
  ;; only install irony if it is linux system
  ;; for windows 'windows-nt' for Mac OS 'darwin'
  (if (eq system-type 'gnu/linux)
      (use-package irony
        :ensure t
        :config
        (add-hook 'c++-mode-hook 'irony-mode)
        (add-hook 'c-mode-hook 'irony-mode)
        (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)))

#+END_SRC

company-c-headers provides auto-completion for c/c++ headers using company,
If you want to complete C++ header files, you have to add its paths,
since by default =company-c-headers= only includes these two system
include paths: =/usr/include/= and =/usr/local/include/=.

To enable C++ header completion for standard libraries, you have to add
its path, for example, like this:
=(add-to-list 'company-c-headers-path-system "/usr/include/c++/4.8/")=
After that, you can complete C++ header files.

To complete project local, use =company-c-headers-path-user= and
put it in =.dir-locals.el=

#+BEGIN_SRC emacs-lisp
  (add-to-list 'company-c-headers-path-system "C:/Qt/Qt5.8.0\\5.8\\Src/qtsensors/include/QtSensors")
  ;; add the below to .dir-locals.el file
  ;; ((nil . ((company-c-headers-path-user . ("D:/Work/Learning/Emacs/my_program/my_inc/")))))
#+END_SRC
**** ggtags
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'ggtags
    (add-hook 'c++-mode-hook 'ggtags-mode)
    (add-hook 'c-mode-hook 'ggtags-mode))
#+END_SRC
*** python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
    (require 'company)
    (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

*** emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbc1")
    (setq slime-contribes '(slime-fancy)))
#+END_SRC

*** bash
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
#+END_SRC
**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'flycheck-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
    (require 'company)
    (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC
* Minor convenience
** Visiting the configuration
Quickly edit =~/.emacs.d/config.org=
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    "Visitthe config.org file"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

** Reloading the configuration
Simply pressing =C-c r= will reload the file, very handy.
You can also manually invoke =M-x config-reload=
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
      "Reload ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

** Subwords
Emacs treats camelCase Strings as a single word by default, this changes said
behavior
#+BEGIN_SRC emacs-lisp
  ;; (global-subword-mode 1)
#+END_SRC

** Electric
If you write andy code, you may enjoy this. Typing the first character
in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already.
Quoting something? It's clocsed for you already.

You can easily add and remove pairs yourself, have a look

#+BEGIN_SRC emacs-lisp
  (setq electric-pair-pairs '(
			     (?\{ . ?\})
			     (?\( . ?\))
			     (?\[ . ?\])
			     (?\" . ?\")
			     ))
#+END_SRC
 
An now to enable it
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode t)
#+END_SRC
** Rainbow
When ever enable a color code, will colorize the background to that color, for example #00FF00
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init (rainbow-mode 1))
#+END_SRC
** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace
character is encountered. You may not like it, 
thus disable it if you must, but it's pretty decent.

=BackSpace= will delete all the white space in between.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful
for any language using them, especially lisp
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** sudo edit
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
    ("s-e" . sudo-edit))

#+END_SRC
** shwo parenthesis mode
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
* Moving around Emacs
** IDO
*** enable ido mode
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching nil)
  (setq ido-create-new-buffer 'always)
  (setq ido-everywhere 1)
  (ido-mode 1)
#+END_SRC

*** ido-vertical-mode
#+BEGIN_SRC emacs-lisp
  (use-package ido-vertical-mode
    :ensure t
    :init
    (ido-vertical-mode 1))
  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
#+END_SRC

*** Smex
for "M-x" quickly command completion and selection
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :init
    (smex-initialize)
    :bind
    ("M-x" . smex))
#+END_SRC

** Helm
It is rather similar to ido-vertical though
#+BEGIN_SRC emacs-lisp
  ;; (use-package helm
  ;;   :ensure t
  ;;   :bind
  ;;   ("C-x C-f" . 'helm-find-files)
  ;;   ("C-x C-b" . 'helm-buffers-list)
  ;;   ("M-x" . 'helm-M-x)
  ;;   :config
  ;;   (defun guo/helm-hide-minibuffer ()
  ;;     (when (with-helm-buffer helm-echo-input-in-header-line)
  ;;       (let((ov (make-overlay (point-min) (point-max) nil nil t)))
  ;;         (overlay-put ov 'window (selected-window))
  ;;         (overlay-put ov 'face
  ;;                      (let ((bg-color (face-background 'default nil)))
  ;;                        `(:background ,bg-color :foreground ,bg-color)))
  ;;         (setq-local cursor-type nil))))
  ;;   (add-hook 'helm-minibuffer-set-up-hook 'guo/helm-hide-minibuffer)
  ;;   (setq helm-autoresize-max-height 0
  ;;         helm-autoresize-min-height 40
  ;;         helm-M-x-fuzzy-match t
  ;;         helm-buffers-fuzzy-matching t
  ;;         helm-recentf-fuzzy-match t
  ;;         helm-semantic-fuzzy-match t
  ;;         helm-imenu-fuzzy-match t
  ;;         helm-split-window-in-side-p nil
  ;;         helm-move-to-line-cycle-in-source nil
  ;;         helm-ff-search-library-in-sexp t
  ;;         helm-scroll-amount 8
  ;;         helm-echo-input-in-header-line t)

  ;;   :init
  ;;   (helm-mode 1))
  ;; (require 'helm-config)
  ;; (helm-autoresize-mode 1)
  ;; (define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
  ;; (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
#+END_SRC
**  buffers
*** enable ibuffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

*** expert
deleting buffers from ibuffer will not ask to confirm
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC

*** switch buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ido-switch-buffer)
#+END_SRC

** avy
for quick go to a place by searching a character and selet the overlay letters
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind
    ("M-s" . avy-goto-char))
#+END_SRC

** ace-window
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    ;; aw-keys - the initial characters used in window labels, default is 1-9
    (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    ;; if you want these keys to work with fewer than three windows, you need to have aw-dispatch-always to t
    (setq aw-dispatch-always t)
    :bind
    ([remap other-window] . ace-window))
#+END_SRC

** following window splits
After you split window, your focus remains in the previous one. 
This annoyed me so much, I wrote these two, they take care of it
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-hoizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Swiper 
swiper is a better search for default search
#+BEGIN_SRC emacs-lisp
  ;; (use-package swiper
  ;;   :ensure t
  ;;   :bind("C-s" . 'swiper))
#+END_SRC

** which-key
To tell you the keyboard binding when pressing =C-c= =C-x= =...=
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
    (which-key-mode))
#+END_SRC

* Text manipulation
Here I shall collect self-made functions that make editing text easier.
** Improved kill-word
Why on earth does a function called kill-word not .. kill a word. It 
instead deletes characters from your cursors position to the end
of the word, lets make a quick fix and bind it properly
#+BEGIN_SRC emacs-lisp
  (defun guo/kill-inner-word ( )
    "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim. "
    (interactive)
    (forward-char 1)
    (backward-word)
    (kill-word 1))
  (global-set-key (kbd "C-c w k") 'guo/kill-inner-word)
#+END_SRC

** copy a word
#+BEGIN_SRC emacs-lisp
  (defun guo/copy-whole-word ()
    (interactive)
    (save-excursion
      (forward-char 1)
      (backward-word)
      (kill-word 1)
      (yank)))
  (global-set-key (kbd "C-c w c") 'guo/copy-whole-word)
#+END_SRC

** copy a line 
#+BEGIN_SRC emacs-lisp
  (defun guo/copy-whole-line ()
    "Copies a line without regard for cursor position."
    (interactive)
    (save-excursion
      (kill-new
       (buffer-substring
	(point-at-bol)
	(point-at-eol)))))
  (global-set-key (kbd "C-c l c") 'guo/copy-whole-line)
#+END_SRC
** kill a line
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l k") 'kill-whole-line)
#+END_SRC

* My Own Setting Section
** Align Regular Expression Setting
*** when align-regexp, using spaces instead of tabs
#+BEGIN_SRC emacs-lisp
(defadvice align-regexp (around align-regexp-with-spaces activate)
  (let ((indent-tabs-mode nil))
    ad-do-it))
#+END_SRC

** Disable Auto Save, Auto Backup and Create Lockfile
#+BEGIN_SRC emacs-lisp
;; disable auto-save and auto-backup
(setq auto-save-default nil)
(setq make-backup-files nil)
;; don't use lockfiles to avoid editng collisions
(setq create-lockfiles nil)

;; store all backup and autosave files in the tmp dir
;; (setq backup-directory-alist
;;       `((".*" . ,temporary-file-directory)))
;; (setq auto-save-file-name-transforms
;;       `((".*" ,temporary-file-directory t)))
#+END_SRC

** High Light Symbol Key Binding
#+BEGIN_SRC emacs-lisp
  ;; highlight-symbol key binding
  (use-package highlight-symbol
    :ensure t
    :config
    (global-set-key [(shift f8)] 'highlight-symbol)
    (global-set-key [f8] 'highlight-symbol-next)
    (global-set-key [(control f8)] 'highlight-symbol-prev)
    (global-set-key [(meta f8)] 'highlight-symbol-query-replace))
#+END_SRC

** Google Translate Direction
#+BEGIN_SRC emacs-lisp
  (use-package google-translate
    :ensure t
    :config
    (setq google-translate-translation-directions-alist
          '(("ja" . "en") ("en" . "de") ("de" . "fr") ("fr" . "de"))))
#+END_SRC

** #If 0 ... #endif Color Dim
#+BEGIN_SRC emacs-lisp
;; #if 0 ... #endif to change the code color as comment color
(add-to-list 'load-path' "~/.emacs.d/MyLisp/")
(require 'never-comment)
(never-comment-init)
#+END_SRC


** Auto Complete
#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    ;; start auto complete with emacs
    (require 'auto-complete)
    ;; do default config for auto-complete
    (require 'auto-complete-config)
    (ac-config-default))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-to-list 'ac-modes 'latex-mode)	;Make auto-complete aware of `latex-mode`
#+END_SRC

# ** Yasnippet
# #+BEGIN_SRC emacs-lisp
#   (require 'yasnippet)
#   ;; (yas-global-mode 1)
# #+END_SRC


# ** Add the package-archives, not used at this moment
# #+BEGIN_SRC emacs-lisp
#   ;; (add-to-list 'package-archives '("ELPA"  . "http://tromey.com/elpa/"))
# #+END_SRC

** qml mode for QT qml file
#+BEGIN_SRC emacs-lisp
  (autoload 'qml-mode "qml-mode" "Editing Qt Declarative." t)
  (add-to-list 'auto-mode-alist '("\\.qml$" . qml-mode))
#+END_SRC


** Org Mode Setting
*** For plantuml to work in org mode
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)
							     (plantuml . t)
							     (C . t)
							     (gnuplot . t)
							     (R . t)
							     (sh . t)
							     )))
  (setq org-plantuml-jar-path
	(expand-file-name "~/plantuml.jar"))

#+END_SRC

** Open the folder containing the current file by the default explorer of the OS
Using -brwse-url-of-file should work when given a directory
#+BEGIN_SRC emacs-lisp
  (defun guo/browse-file-directory ()
    "Open the crrent file's directory however the OS would"
    (interactive)
    (if default-directory
	(browse-url-of-file (expand-file-name default-directory))
      (error "No `default-directory` to open")))
#+END_SRC

* org Mode
** Common settings
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC

** htmlize
Systax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Easy to add emacs-lisp template in org mode
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
* screen shot
** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
  (defun guo/take-screenshot ()
    "Takes a fullscreen screen shot of the current workspace"
    (interactive)
    (when window-system
      (cl-loop for i downfrom 3 to 1 do
	    (progn
	      (message (concat (number-to-string i) "..."))
	      (sit-for 1)))
      (message "Cheese!")
      (start-process "screenshot" nil "import" "-window" "root"
		     (concat (getenv "HOME") "/Desktop/" (cl-subseq (number-to-string (float-time)) 0 10) ".png"))
      (message "Screenshot taken")))
  (global-set-key (kbd "<print>") 'guo/take-screenshot)

#+END_SRC

** Screenshotting region
#+BEGIN_SRC emacs-lisp
  (defun guo/take-screenshot-region ()
    "Takes a screenshot of a region selected by the user."
    (interactive)
    (when window-system
    (call-process "import" nil nil nil ".newScreen.png")
    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
		  (concat (getenv "HOME") "/Desktop/" (cl-subseq (number-to-string (float-time)) 0 10) ".png"))
    (call-process "rm" nil nil nil ".newScreen.png")))
  (global-set-key (kbd "<Scroll_Lock>") 'guo/take-screenshot-region)
#+END_SRC
* git integration
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq magit-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC
* set LD_LIBRARY_PATH
** function for set LD_LIBRARY_PATH
#+BEGIN_SRC emacs-lisp
  (defun guo/set-ld-library-Path (path)
    (interactive)
    (setenv "LD_LIBRARY_PATH"
            (let((current (getenv "LD_LIBRARY_PATH"))
                 (new path))
              (if current
                  (concat new ":" current)
                new))))
#+END_SRC

** set LD_LIBRARY_PATH
use =gcc -xc++ -E -v= to search for the gcc search path,
used for irony-mode for searching library or path.
#+BEGIN_SRC shell
/usr/include/c++/4.8
/usr/include/x86_64-linux-gnu/c++/4.8
/usr/include/c++/4.8/backward
/usr/lib/gcc/x86_64-linux-gnu/4.8/include
/usr/local/include
/usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed
/usr/include/x86_64-linux-gnu
/usr/include
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (guo/set-ld-library-Path "/usr/lib/llvm-3.4/lib/")
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (getenv "LD_LIBRARY_PATH")
#+END_SRC

* set LIBCLANG_LIBRARY
#+BEGIN_SRC emacs-lisp
  (setenv "LIBCLANG_LIBRARY" "/usr/lib/llvm-3.4/lib/libclang.so.1")
  (getenv "LIBCLANG_LIBRARY")
#+END_SRC

* set LIBCLANG_INCLUDE_DIR
#+BEGIN_SRC emacs-lisp
  (setenv "LIBCLANG_INCLUDE_DIR" "/usr/lib/llvm-3.4/include")
  (getenv "LIBCLANG_INCLUDE_DIR")
#+END_SRC

* cygwin-shell function and enable if if it is windows
#+BEGIN_SRC emacs-lisp
  ;; for windows 'windows-nt' for Mac OS 'darwin'
  ;; shell-file-name is thevariable that controls wich shell Emacs uses
  ;; when it wants to runa shell command.

  ;; explicit-shell-file-name is thevariable that controls wich shell =M-x shell=
  ;; starts up.
  (if (eq system-type 'windows-nt)
      (defun guo/cygwin-shell ()
	"Run cygwin bash in shell mode."
	(interactive)
	(let ((explicit-shell-file-name "C:/cygwin64/bin/bash")
	      )
	  (call-interactively 'shell)))
    )
#+END_SRC
* project find file
#+BEGIN_SRC emacs-lisp
;; Find file in project
(global-set-key (kbd "C-x M-f") 'project-find-file)
#+END_SRC
* Auctex
** 1) auctex install from package install, 
try this first, if not working, need to install manually as below 2
#+BEGIN_SRC emacs-lisp
  (use-package auctex			;
    :defer t
    :ensure t
    :config
    (setq TeX-auto-save t))
  ;; alternative or better configuration
  ;; (use-package tex
  ;;   :defer t
  ;;   :ensure auctex
  ;;   :config
  ;;   (setq TeX-auto-save t))
#+END_SRC

** 2) manual install auctex
auctex is not working solution for windows 7 in company
auctex-12.1 installed from package-install is not working on windows 7 in company
need to install auctex manually.

If installed from package-install, delete the package from elpa directory,
remove the auctex from init.el file from packaged-installed

uncomment the code below
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'load-path' "~/.emacs.d/site-lisp/auctex-11.89")
  ;; (require 'tex-site)
>>>>>>> 7a5df392ead164c817e6619be3e56b5cf01a1f90
#+END_SRC
